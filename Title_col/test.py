from PIL import Image
import numpy as np
import cv2
from colorthief import ColorThief
from collections import Counter
from collections import defaultdict
import re
import pandas as pd
import os

## The 15 colours generated by orginal_into_k for the render map split into 15 dominate colours via k means
The_15_cols = ['(192, 183, 143)', '(170, 163, 128)', '(144, 137, 103)', '(133, 167, 38)', '(96, 83, 49)', '(237, 234, 210)', '(220, 88, 37)', '(213, 200, 158)', '(156, 130, 125)', '(128, 126, 121)', '(112, 106, 83)', '(61, 98, 25)', '(54, 56, 40)', '(23, 26, 13)', '(13, 0, 149)']

## an empty array that will be used to store each tiles percenatge pixel make up.
All_percenatge_make_up = []


## https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_ml/py_kmeans/py_kmeans_opencv/py_kmeans_opencv.html

## Code that was needed to split an image into k of the the most dominate colours and put them back together.  This is know as Color Quantization
def orginal_into_k(k):

    ## read in the image of the map
    map = cv2.imread("Capture3.PNG")

        # reshape the image to make it easier to work on
    Z = map.reshape((-1, 3))
        # convert to np.float32
    Z = np.float32(Z)

        # define criteria, number of clusters(K) and apply kmeans()
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)

    K = k

    ret,label,center=cv2.kmeans(Z,K,None,criteria,10,cv2.KMEANS_RANDOM_CENTERS)

    # convert the image back into uint8 to make the original image
    center = np.uint8(center)
    res = center[label.flatten()]
    res2 = res.reshape((map.shape))

    #(cv2.imshow('res2',res2))

    # Save the Color Quantization version of the render map
    cv2.imwrite("K15_map.png", res2)

    #cv2.waitKey(0)
    #cv2.destroyAllWindows()


## Work out how much (percenatge wise) of each of the K means colours appear in the data frame.
def tile_class(img,name):

    image_ = img

    ##Get the RGB colour of an inputted image
    colors = image_.convert('RGB').getcolors()

    regex = "\((.*?)\)"

    ## A vector to store the RGB values found in the data frame
    rgb_colours_clean = []

    ## A loop to basically clean the up the RGB values gotten
    ## getcolors() will give us ( X, (R,G,B))
    ## We only want the R,G,B values so remove X from the result and store the wanted values into a vector
    for x in colors:
        test = str(x)[1:-1]
        #print(test)
        regex = "\((.*?)\)"
        a = re.search(regex, str(test))
        rgb_colours_clean.append(a.group())

    ## get the amount of pixles we will need to itterate through
    width, height = image_.size

    #print(rgb_colours_clean)

    ## Store the percenatge make up of the diffrent RGB values into a new array
    Whats_in_the_tile = []

    ## For all RGB colours
    for x in rgb_colours_clean:

        i = 0
        ## Loop through X cords
        for w in range(width):
            ## Loop through Y cords
            for h in range(height):
                ## Get the current colour in that pixel
                current_color = img.getpixel((w, h))

                ## If the current pixle colour is the colour x increment the counter by one
                if str(current_color) == str(x):
                    i = i + 1

        ## work out the percenatge
        Whats_in_the_tile.append([str(x), i / (width * height)])

    ## Create the rows of the dataframe
    ## Each row will contian each of the 15 colours and how the percenatge make up of each colour
    a_test = []

    ## look through the 15 colour
    for y in The_15_cols:

        ## If that colour appears in the tile
        if any(y in sublist for sublist in Whats_in_the_tile):

            ## For every colour int the tile
            for x in range(len(Whats_in_the_tile)):
                ## Add the row to a data frame
                if str(y) == (Whats_in_the_tile[x][0]):

                    a_test.append([y, Whats_in_the_tile[x][1]])

        else:
            ## the colour dosnt appear in the list so set the percenatge to zero
            a_test.append([y, 0])

    ## Add the row to the list
    All_percenatge_make_up.append([name, a_test])


## A function to convert an array into a dataframe
def tile_class_Df(the_array):

    ## create a df
    df = pd.DataFrame(columns=['tile', '(192, 183, 143)', '(170, 163, 128)', '(144, 137, 103)', '(133, 167, 38)', '(96, 83, 49)', '(237, 234, 210)', '(220, 88, 37)', '(213, 200, 158)', '(156, 130, 125)', '(128, 126, 121)', '(112, 106, 83)', '(61, 98, 25)', '(54, 56, 40)', '(23, 26, 13)', '(13, 0, 149)'])

    ## For each row in the data frame
    for a in range(len(the_array)):

        ## Add the appropriate value from the array into the data frame
        df = df.append({'tile': the_array[a][0],
                        '(192, 183, 143)': the_array[a][1][0][1],
                        '(170, 163, 128)': the_array[a][1][1][1],
                        '(144, 137, 103)': the_array[a][1][2][1],
                        '(133, 167, 38)': the_array[a][1][3][1],
                        '(96, 83, 49)': the_array[a][1][4][1],
                        '(237, 234, 210)': the_array[a][1][5][1],
                        '(220, 88, 37)': the_array[a][1][6][1],
                        '(213, 200, 158)': the_array[a][1][7][1],
                        '(156, 130, 125)': the_array[a][1][8][1],
                        '(128, 126, 121)': the_array[a][1][9][1],
                        '(112, 106, 83)': the_array[a][1][10][1],
                        '(61, 98, 25)': the_array[a][1][11][1],
                        '(54, 56, 40)': the_array[a][1][12][1],
                        '(23, 26, 13)': the_array[a][1][13][1],
                        '(13, 0, 149)': the_array[a][1][14][1]}, ignore_index=True)

    return(df)

##Give a file of tile images. Work out the percenatge makeup of each colour in the the tile and create a daata frame out of the results
def run_it(dirc_name, file_name, save_name):

    i = 1

    for filename in os.listdir(dirc_name):

        print(i)
        tile_class(Image.open((file_name)+str(filename)), str(filename))
        i = i + 1

    print("Array made")
    finshed = tile_class_Df(All_percenatge_make_up)

    print(finshed)
    print("finshed")
    finshed.to_csv(str(save_name) + ".csv")


##Coded needed if you have got the tiles for level 8 and want to find out what is in each tile
#run_it("C:/Users/Callum/PycharmProjects/Title_col/8_tiles","8_tiles/","tiles_colour")

##Coded needed if you have got the tiles for level 12 and want to find out what is in each tile
#run_it("C:/Users/Callum/PycharmProjects/Title_col/256_tiles", "256_tiles/" , "tiles_colour_256")
